# Decisions made in `Ingestor` Bounded Context (in no particular order)
### Why using `httpClient` instead of `Guzzle`?
Simplicity reasons: `Guzzle` is widely used for HTTP requests, but it adds an extra layer of complexity to our codebase. 
Our external provider only exposes `GET` endpoints, so no need to have (and maintain) an all-purpose library (like `Guzzle`) when a simpler and more lightweight option allows us to do the trick.

### What if our external provider has thousands of events with hundreds of zones each? 
The CLI uses the `src/Ingestor/Infrastructure/XmlEventsStreamReader` class to reads from XML using streaming to avoid memory exhaustion.
It also processes in batches (default size is 50, but it could be increased if needed).

That combination of factors (streaming + batch processing) allows us to process any number of events with constant memory usage (around 5 MB).

### How this BC could be scaled in the future?
Right now the events are processed synchronously, but if we need to scale it in the future we could easily switch to an asynchronous processing using Symfony Messenger.
In theory, it should be as easy as adding this config:
```yaml
# config/packages/messenger.yaml
framework:
    messenger:
        transports:
            async: '%env(MESSENGER_TRANSPORT_DSN)%'
        
        routing:
            'Ingestor\Application\IngestEventsCommand': async
```
We would need to configure a transport (`Redis` would be my go-to choice) and make sure the `IngestEventsCommand` can be (de)serialized, but the other parts of the BC should remain unchanged.

*NOTE TO ME: Implement this if I have time*
