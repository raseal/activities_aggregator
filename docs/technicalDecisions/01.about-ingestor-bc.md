# Decisions made in `Ingestor` Bounded Context (in no particular order)
### Why using `httpClient` instead of `Guzzle`?
Simplicity reasons: `Guzzle` is widely used for HTTP requests, but it adds an extra layer of complexity to our codebase. 
Our external provider only exposes `GET` endpoints, so no need to have (and maintain) an all-purpose library (like `Guzzle`) when a simpler and more lightweight option allows us to do the trick.

### What if our external provider has thousands of events with hundreds of zones each? 
The CLI uses the `src/Ingestor/Infrastructure/XmlEventsStreamReader` class to reads from XML using streaming to avoid memory exhaustion.
It also processes in batches (default size is 50, but it could be increased if needed).

That combination of factors (streaming + batch processing) allows us to process any number of events with constant memory usage (around 5 MB).

When the batch arrives at the `src/Ingestor/Application/IngestEventsCommandHandler.php`, it sends its events (one by one) to a Redis instance to be processed asynchronously.
That means we can have dedicated workers to process the events in the background, and we can scale them up or down depending on the workload.

The messages in Redis are stored as JSON strings, so they are interoperable (and also, easy to read, debug and test).

### Why the `Zone.price` is converted as `int`?
In order to avoid floating point precision issues, I decided to store the price as an integer representing the amount in cents.
I would also have liked using the `Money` pattern in this particular VO, but the endpoint does not provide the currency.

### About rabbit queues...
We have N queues (N = number of domain events). The *exchange name* is `domain_events` and the *routing key* is the name of the event (e.g. `event_created`, `event_updated`, etc.).
When the project is built (`make build`), there is a process (located in `etc/scripts/wait-for-rabbitmq.sh`) that waits for RabbitMQ to be ready and then creates the queues and the exchange.

The idea behind having one queue per event is to have a clear separation of concerns and to be able to scale each queue independently. For example, if we have a lot of `event_created` events, we can scale up the workers that consume from that queue without affecting the other queues.

**Sure, the naming (wait-for-rabbitmq) is not the best one, but it does the job.**
