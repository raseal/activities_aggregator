# How this project works?
## Quick overview
There are two different Bounded Contexts:
1. `src/Ingestor`
2. `src/Catalog`

First one is about ingesting the data from our external provider and transforming it into a format that we can use in our system. 
The second one is about exposing the data to our clients through an API. 
This separation of concerns allows us to have a clear and maintainable codebase, where each Bounded Context is responsible for a specific part of the system.

## How is this project structured?
All Symfony stuff (framework, bundles, config, CLI, controllers...) is located inside `apps/SymfonyClient` folder. 
That way we have a clear separation between the framework and the business logic, which is located in`src` folder.

In `src` folder we have three bounded contexts:
- `Ingestor`: to handle the data from external provider
- `Catalog`: to handle the API and expose the data to our clients
- `Shared`: to handle the shared code between the two bounded contexts (base VOs, contracts, Symfony customizations...)

## How the BC are connected?
At the `Ingestor` we have a cronjob that runs every X hours and fetches the XML file from the provider. It then parses the XML and stores the data in a database.
Once an event is stored, the `Ingestor` publishes a `Domain event` to notify the `Catalog` about the new event or update.

The `Catalog` listens to the `Domain events` published by the `Ingestor` and updates its own projections accordingly.

## Why do we have so many Symfony customizations?
Because Symfony is great, but some of its components are not designed to be used in a DDD context. 
For example, `symfony/messenger` tends to serialize messages in a non-interoperable format, making difficult to (for example) producing / publishing messages with different languages.
